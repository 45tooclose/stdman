.TH std::longjmp 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   Defined in header <csetjmp>
   void longjmp( std::jmp_buf env, int status );

   Loads the execution context env saved by a previous call to setjmp. This function
   does not return. Control is transferred to the call site of the macro setjmp that
   set up env. That setjmp then returns the value, passed as the status.

   If the function that called setjmp has exited, the behavior is undefined (in other
   words, only long jumps up the call stack are allowed)

   No destructors for automatic objects are called. If replacing of std::longjmp with
   throw and setjmp with catch would execute a non-trivial destructor for any automatic
   object, the behavior of such std::longjmp is undefined.

.SH Contents

     * 1 Parameters
     * 2 Return value
     * 3 Example
     * 4 See also

.SH Parameters

   env    - variable referring to the execution state of the program saved by
            std::setjmp
   status - the value to return from setjmp. If it is equal to 0, 1 is used instead

.SH Return value

   \fI(none)\fP

.SH Example

   
// Run this code

 #include <iostream>
 #include <csetjmp>

 std::jmp_buf jump_buffer;

 [[noreturn]] void a(int count)
 {
     std::cout << "a(" << count << ") called\\n";
     std::longjmp(jump_buffer, count+1);  // setjump() will return count+1
 }

 int main()
 {
     int count = setjmp(jump_buffer);
     if (count != 9) {
         a(count);  // This will cause setjmp() to exit
     }
 }

.SH Output:

 a\fB(0)\fP called
 a\fB(1)\fP called
 a\fB(2)\fP called
 a\fB(3)\fP called
 a\fB(4)\fP called
 a\fB(5)\fP called
 a\fB(6)\fP called
 a\fB(7)\fP called
 a\fB(8)\fP called

.SH See also

   setjmp saves the context
          \fI(function macro)\fP
   C documentation for
   longjmp
