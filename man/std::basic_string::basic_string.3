.TH std::basic_string::basic_string 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   explicit basic_string( const Allocator& alloc = Allocator() );     \fB(1)\fP
   basic_string( size_type count,

   CharT ch,                                                          \fB(2)\fP

   const Allocator& alloc = Allocator() );
   basic_string( const basic_string& other,

   size_type pos,                                                     \fB(3)\fP
   size_type count = std::basic_string::npos,

   const Allocator& alloc = Allocator() );
   basic_string( const CharT* s,

   size_type count,                                                   \fB(4)\fP

   const Allocator& alloc = Allocator() );
   basic_string( const CharT* s,                                      \fB(5)\fP
   const Allocator& alloc = Allocator() );
   template< class InputIt >

   basic_string( InputIt first, InputIt last,                         \fB(6)\fP

   const Allocator& alloc = Allocator() );
   basic_string( const basic_string& other );                         \fB(7)\fP
   basic_string( const basic_string& other, const Allocator& alloc ); \fB(7)\fP \fI(since C++11)\fP
   basic_string( basic_string&& other )                               \fB(8)\fP \fI(since C++11)\fP
   basic_string( basic_string&& other, const Allocator& alloc );      \fB(8)\fP \fI(since C++11)\fP
   basic_string( std::initializer_list<CharT> init,                   \fB(9)\fP \fI(since C++11)\fP
   const Allocator& alloc = Allocator() );

   Constructs new string from a variety of data sources and optionally using user
   supplied allocator alloc.

   1) Default constructor. Constructs empty string.
   2) Constructs the string with count copies of character ch.
   3) Constructs the string with a substring [pos, pos+count) of other. If the
   requested substring lasts past the end of the string, or if count == npos, the
   resulting substring is [pos, size()). If pos >= other.size(), std::out_of_range is
   thrown.
   4) Constructs the string with the first count characters of character string pointed
   to by s. s can contain null characters. The behavior is undefined if s does not
   point at an array of at least count elements of CharT.
   5) Constructs the string with the contents initialized with a copy of the
   null-terminated character string pointed to by s. The length of the string is
   determined by the first null character. The behavior is undefined if s does not
   point at an array of at least Traits::length(s)+1 elements of CharT.
   6) Constructs the string with the contents of the range [first, last).
   7) Copy constructor. Constructs the string with the copy of the contents of other.
   8) Move constructor. Constructs the string with the contents of other using move
   semantics.
   9) Constructs the string with the contents of the initializer list init.

.SH Contents

     * 1 Parameters
     * 2 Complexity
     * 3 Example
     * 4 See also

.SH Parameters

   alloc       - allocator to use for all memory allocations of this string
   count       - size of the resulting string
   ch          - value to initialize the string with
   first, last - range to copy the characters from
   s           - pointer to a character string to use
                 as source to initialize the string with
   other       - another string to use as source to initialize the string with
   init        - initializer list to initialize the string with
.SH Type requirements
   -
   InputIt must meet the requirements of InputIterator.

.SH Complexity

   1) constant

   2-4) linear in count

   5) linear in length of s

   6) linear in distance between first and last

   7) linear in size of other

   8) constant. If alloc is given and alloc != other.get_allocator(), then linear.

   9) linear in size of init

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   assign    assign characters to a string
             \fI(public member function)\fP
   operator= assigns values to the string
             \fI(public member function)\fP

.SH Category:

     * Todo no example
