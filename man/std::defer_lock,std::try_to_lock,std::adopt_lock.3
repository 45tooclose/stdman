.TH std::defer_lock,std::try_to_lock,std::adopt_lock 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   constexpr std::defer_lock_t defer_lock = std::defer_lock_t();     \fI(since C++11)\fP
   constexpr std::try_to_lock_t try_to_lock = std::try_to_lock_t();  \fI(since C++11)\fP
   constexpr std::adopt_lock_t adopt_lock = std::adopt_lock_t();     \fI(since C++11)\fP

   std::defer_lock, std::try_to_lock and std::adopt_lock are instances of empty struct
   tag types std::defer_lock_t, std::try_to_lock_t and std::adopt_lock_t respectively.

   They are used to specify locking strategies for std::lock_guard and
   std::unique_lock.

   Type          Effect(s)
   defer_lock_t  do not acquire ownership of the mutex
   try_to_lock_t try to acquire ownership of the mutex without blocking
   adopt_lock_t  assume the calling thread already has ownership of the mutex

.SH Example

   
// Run this code

 #include <mutex>
 #include <thread>
  
 struct bank_account {
     explicit bank_account(int balance) : balance(balance) {}
     int balance;
     std::mutex m;
 };
  
 void transfer(bank_account &from, bank_account &to, int amount)
 {
     // attempt to lock both mutexes without deadlock
     std::lock(from.m, to.m);
  
     // make sure both already-locked mutexes are unlocked when
     // we're done; if we just used the lock_guard without std::lock
     // and std::adopt_lock, we might deadlock with other calls to transfer
     std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);
     std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);
  
     from.balance -= amount;
     to.balance += amount;
 }
  
 int main()
 {
     bank_account my_account(100);
     bank_account your_account(50);
  
     std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);
     std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);
  
     t1.join();
     t2.join();
 }

.SH See also

   defer_lock_t
   try_to_lock_t
   adopt_lock_t  tag type used to specify locking strategy
   \fI(C++11)\fP       \fI(class)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   constructor   constructs a lock_guard, optionally locking the given mutex
                 \fI(public member function of std::lock_guard)\fP
   constructor   constructs a unique_lock, optionally locking the supplied mutex
                 \fI(public member function of std::unique_lock)\fP
