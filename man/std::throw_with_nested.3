.TH std::throw_with_nested 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   Defined in header <exception>
   template< class T >                            \fI(since C++11)\fP
   [[noreturn]] void throw_with_nested( T&& t );

   Throws an exception of unspecified type that is derived from both
   std::nested_exception and from std::remove_reference<T>::type, and constructed from
   std::forward<T>(t). The default constructor of the nested_exception parent calls
   std::current_exception, capturing the currently handled exception object, if any, in
   std::exception_ptr.

   If std::remove_reference<T>::type is already derived from std::nested_exception,
   simply throws std::forward<T>(t).

   Requires that std::remove_reference<T>::type is CopyConstructible

.SH Contents

     • 1 Parameters
     • 2 Return value
     • 3 Example
     • 4 See also

.SH Parameters

   t - the exception object to throw

.SH Return value

   \fI(none)\fP

.SH Example

   Demonstrates construction and recursion through a nested exception object

   
// Run this code

 #include <iostream>
 #include <stdexcept>
 #include <exception>
 #include <string>
 #include <fstream>

 // prints the explanatory string of an exception. If the exception is nested,
 // recurses to print the explanatory of the exception it holds
 void print_exception(const std::exception& e, int level =  0)
 {
     std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\\n';
     try {
         std::rethrow_if_nested(e);
     } catch(const std::exception& e) {
         print_exception(e, level+1);
     } catch(...) {}
 }

 // sample function that catches an exception and wraps it in a nested exception
 void open_file(const std::string& s)
 {
     try {
         std::ifstream file(s);
         file.exceptions(std::ios_base::failbit);
     } catch(...) {
         std::throw_with_nested( std::runtime_error("Couldn't open " + s) );
     }
 }

 // sample function that catches an exception and wraps it in a nested exception
 void run()
 {
     try {
         open_file("nonexistent.file");
     } catch(...) {
         std::throw_with_nested( std::runtime_error("run() failed") );
     }
 }

 // runs the sample function above and prints the caught exception
 int main()
 {
     try {
         run();
     } catch(const std::exception& e) {
         print_exception(e);
     }
 }

.SH Output:

 exception: run() failed
  exception: Couldn't open nonexistent.file
   exception: basic_ios::clear

.SH See also

   nested_exception  a mixin type to capture and store current exceptions
   \fI(C++11)\fP           \fI(class)\fP
   rethrow_if_nested throws the exception from a std::nested_exception
   \fI(C++11)\fP           \fI(function template)\fP
