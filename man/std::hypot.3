.TH std::hypot 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::hypot \- std::hypot

.SH Synopsis
   Defined in header <cmath>
   float       hypot( float x, float y );             \fB(1)\fP \fI(since C++11)\fP
   double      hypot( double x, double y );           \fB(2)\fP \fI(since C++11)\fP
   long double hypot( long double x, long double y ); \fB(3)\fP \fI(since C++11)\fP
   Promoted    hypot( Arithmetic1 x, Arithmetic2 y ); \fB(4)\fP \fI(since C++11)\fP

   Computes the square root of the sum of the squares of x and y, without undue
   overflow or underflow at intermediate stages of the computation. This is the length
   of the hypotenuse of a right-angled triangle with sides of length x and y, or the
   distance of the point (x,y) from the origin (0,0), or the magnitude of a complex
   number x+iy

   4) If any argument has integral type, it is cast to double. If any other argument is
   long double, then the return type is long double, otherwise it is double.

.SH Parameters

   x, y - values of floating-point or integral types

.SH Return value

   The hypotenuse of a right-angled triangle,
   √
   x2
   +y2
   .

.SH Exceptions

   If the result overflows, a range error may occur and FE_OVERFLOW may be raised.

   If the result is subnormal, an underflow error may occur and FE_UNDERFLOW may be
   raised.

.SH Notes

   Implementations usually guarantee precision of less than 1 ulp (units in the last
   place): GNU, BSD, Open64

.SH Example

   
// Run this code

 #include <cmath>
 #include <utility>
 #include <iostream>
  
 std::pair<double, double> cartesian_to_polar(double x, double y)
 {
     return {std::hypot(x, y), std::atan2(y,x)};
 }
  
 int main()
 {
     std::pair<double, double> polar = cartesian_to_polar(1, 1);
     std::cout << "(1,1) cartesian is (" << polar.first
                << "," << polar.second<< ") polar\\n";
 }

.SH Output:

 (1,1) cartesian is (1.41421,0.785398) polar

.SH See also

                     computes square root (
   sqrt              √
                     x)
                     \fI(function)\fP 
   pow               raises a number to the given power (x^y)
                     \fI(function)\fP 
   abs(std::complex) returns the magnitude of a complex number
                     \fI(function template)\fP 
   C documentation for
   hypot
