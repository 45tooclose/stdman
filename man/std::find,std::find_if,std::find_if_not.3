.TH std::find,std::find_if,std::find_if_not 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::find,std::find_if,std::find_if_not \- std::find,std::find_if,std::find_if_not

.SH Synopsis
   Defined in header <algorithm>
   template< class InputIt, class T >                           \fB(1)\fP
   InputIt find( InputIt first, InputIt last, const T& value );
   template< class InputIt, class UnaryPredicate >

   InputIt find_if( InputIt first, InputIt last,                \fB(2)\fP

                    UnaryPredicate p );
   template< class InputIt, class UnaryPredicate >

   InputIt find_if_not( InputIt first, InputIt last,            \fB(3)\fP \fI(since C++11)\fP

                        UnaryPredicate q );

   Returns the first element in the range [first, last) that satisfies specific
   criteria:

   1) find searches for an element equal to value
   2) find_if searches for an element for which predicate p returns true
   3) find_if_not searches for element for which predicate q returns false

.SH Parameters

   first, last - the range of elements to examine
   value       - value to compare the elements to
                 unary predicate which returns true for the required element.

                 The signature of the predicate function should be equivalent to the
                 following:

   p           -  bool pred(const Type &a);

                 The signature does not need to have const &, but the function must not
                 modify the objects passed to it.
                 The type Type must be such that an object of type InputIt can be
                 dereferenced and then implicitly converted to Type. 
                 unary predicate which returns false for the required element.

                 The signature of the predicate function should be equivalent to the
                 following:

   q           -  bool pred(const Type &a);

                 The signature does not need to have const &, but the function must not
                 modify the objects passed to it.
                 The type Type must be such that an object of type InputIt can be
                 dereferenced and then implicitly converted to Type. 
.SH Type requirements
   -
   InputIt must meet the requirements of InputIterator.
   -
   UnaryPredicate must meet the requirements of Predicate.

.SH Return value

   Iterator to the first element satisfying the condition or last if no such element is
   found.

.SH Complexity

   At most last - first applications of the predicate

.SH Possible implementation

.SH First version
   template<class InputIt, class T>
   InputIt find(InputIt first, InputIt last, const T& value)
   {
       for (; first != last; ++first) {
           if (*first == value) {
               return first;
           }
       }
       return last;
   }
.SH Second version
   template<class InputIt, class UnaryPredicate>
   InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
   {
       for (; first != last; ++first) {
           if (p(*first)) {
               return first;
           }
       }
       return last;
   }
                             Third version
   template<class InputIt, class UnaryPredicate>
   InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
   {
       for (; first != last; ++first) {
           if (!q(*first)) {
               return first;
           }
       }
       return last;
   }

   If you do not have C++11, an equivalent to std::find_if_not is to use std::find_if
   with the negated predicate.

   template<class InputIt, class UnaryPredicate>
   InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
   {
       return std::find_if(first, last, std::not1(q));
   }

.SH Example

   The following example finds an integer in a vector of integers.

   
// Run this code

 #include <iostream>
 #include <algorithm>
 #include <vector>
 #include <iterator>
  
 int main()
 {
     int n1 = 3;
     int n2 = 5;
  
     std::vector<int> v{0, 1, 2, 3, 4};
  
     auto result1 = std::find(std::begin(v), std::end(v), n1);
     auto result2 = std::find(std::begin(v), std::end(v), n2);
  
     if (result1 != std::end(v)) {
         std::cout << "v contains: " << n1 << '\\n';
     } else {
         std::cout << "v does not contain: " << n1 << '\\n';
     }
  
     if (result2 != std::end(v)) {
         std::cout << "v contains: " << n2 << '\\n';
     } else {
         std::cout << "v does not contain: " << n2 << '\\n';
     }
 }

.SH Output:

 v contains: 3
 v does not contain: 5

.SH See also

                 finds two identical (or some other relationship) items adjacent to
   adjacent_find each other
                 \fI(function template)\fP 
   find_end      finds the last sequence of elements in a certain range
                 \fI(function template)\fP 
   find_first_of searches for any one of a set of elements
                 \fI(function template)\fP 
   mismatch      finds the first position where two ranges differ
                 \fI(function template)\fP 
   search        searches for a range of elements
                 \fI(function template)\fP 
