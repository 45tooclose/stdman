.TH std::raw_storage_iterator 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   Defined in header <memory>
   template< class OutputIt, class T >

   class raw_storage_iterator

       : public std::iterator<std::output_iterator_tag, void, void, void, void>;

   The output iterator std::raw_storage_iterator makes it possible for standard
   algorithms to store results in uninitialized memory. Whenever the algorithm writes
   an object of type T to the dereferenced iterator, the object is copy-constructed
   into the location in the uninitialized storage pointed to by the iterator. The
   template parameter OutputIt is any type that meets thee requirements of
   OutputIterator and has operator* defined to return an object, for which operator&
   returns an object of type T*. Usually, the type T* is used as OutputIt.

.SH Contents

     • 1 Type requirements
     • 2 Member functions
     • 3 Inherited from
       std::iterator

          • 3.1 Member types
          • 3.2 Example
          • 3.3 See also

.SH Type requirements

   -
   OutputIt must meet the requirements of OutputIterator.

.SH Member functions

   constructor     creates a new raw_storage_iterator
                   \fI(public member function)\fP
   operator=       copy-constructs an object at the pointed-to location in the buffer
                   \fI(public member function)\fP
   operator*       dereferences the iterator
                   \fI(public member function)\fP
   operator++      advances the iterator
   operator++(int) \fI(public member function)\fP

Inherited from std::iterator

.SH Member types

   Member type       Definition
   value_type        void
   difference_type   void
   pointer           void
   reference         void
   iterator_category std::output_iterator_tag

.SH Example

   
// Run this code

 #include <iostream>
 #include <string>
 #include <memory>
 #include <algorithm>
  
 int main()
 {
     const std::string s[] = {"This", "is", "a", "test", "."};
     std::string* p = std::get_temporary_buffer<std::string>(5).first;
  
     std::copy(std::begin(s), std::end(s),
               std::raw_storage_iterator<std::string*, std::string>(p));
  
     for(std::string* i = p; i!=p+5; ++i) {
         std::cout << *i << '\\n';
         i->~basic_string<char>();
     }
     std::return_temporary_buffer(p);
 }

.SH Output:

 This
 is
 a
 test
 .

.SH See also

   allocator_traits         provides information about allocator types
   \fI(C++11)\fP                  \fI(class template)\fP
   scoped_allocator_adaptor implements multi-level allocator for multi-level containers
   \fI(C++11)\fP                  \fI(class template)\fP
   uses_allocator           checks if the specified type supports uses-allocator
   \fI(C++11)\fP                  construction
                            \fI(class template)\fP
