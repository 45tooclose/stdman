.TH std::atomic::fetch_add 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic::fetch_add \- std::atomic::fetch_add

.SH Synopsis
   T fetch_add( T arg,
                memory_order =
   std::memory_order_seq_cst );
   T fetch_add( T arg,                          \fI(since C++11)\fP
                memory_order =                  (member only of
   std::memory_order_seq_cst ) volatile;    \fB(1)\fP atomic<Integral>
   T* fetch_add( std::ptrdiff_t arg,            template             \fI(since C++11)\fP
                 memory_order =                 specialization)      (member only of
   std::memory_order_seq_cst );                                  \fB(2)\fP atomic<Integral>
   T* fetch_add( std::ptrdiff_t arg,                                 template
                 memory_order =                                      specialization)
   std::memory_order_seq_cst ) volatile;

   Atomically replaces the current value with the result of arithmetic addition of the
   value and arg. The operation is read-modify-write operation. Memory is affected
   according to the value of memory_order.

   For signed Integral types, arithmetic is defined to use twoâ€™s complement
   representation. There are no undefined results. For T* types, the result may be an
   undefined address, but the operations otherwise have no undefined behavior.

.SH Parameters

   arg          - the other argument of arithmetic addition
   memory_order - memory order constraints to enforce

.SH Return value

   The value of the atomic variable before the call.

.SH Exceptions

   noexcept specification:  
   noexcept
     

.SH See also

   atomic_fetch_add          adds a non-atomic value to an atomic object and obtains
   atomic_fetch_add_explicit the previous value of the atomic
   \fI(C++11)\fP                   \fI(function template)\fP 
   \fI(C++11)\fP
