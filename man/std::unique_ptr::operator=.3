.TH std::unique_ptr::operator= 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   unique_ptr& operator=( unique_ptr&& r );      \fB(1)\fP \fI(since C++11)\fP
   template< class U, class E >                  \fB(1)\fP \fI(since C++11)\fP
   unique_ptr& operator=( unique_ptr<U,E>&& r );
   unique_ptr& operator=( nullptr_t );           \fB(2)\fP \fI(since C++11)\fP

   1) Transfers ownership of the object pointed to by r to *this as if by calling
   reset(r.release()) followed by an assignment of get_deleter() from
   std::forward<E>(r.get_deleter()).

   2) Effectively the same as calling reset().

   Note that unique_ptr's assignment operator only accepts xvalues, which are typically
   generated by std::move. (The unique_ptr class explicitly deletes its lvalue copy
   constructor and lvalue assignment operator.)

.SH Contents

     • 1 Parameters
     • 2 Return value
     • 3 Exceptions
     • 4 Example

.SH Parameters

   r - smart pointer from which ownership will be transfered

.SH Return value

   *this

.SH Exceptions

   noexcept specification:
   noexcept

.SH Example

   
// Run this code

 #include <iostream>
 #include <memory>

 struct Foo {
     Foo() { std::cout << "Foo\\n"; }
     ~Foo() { std::cout << "~Foo\\n"; }
 };

 int main()
 {
     std::unique_ptr<Foo> p1;

     {
         std::cout << "Creating new Foo...\\n";
         std::unique_ptr<Foo> p2(new Foo);
         // p1 = p2; // Error ! can't copy unique_ptr
         p1 = std::move(p2);
         std::cout << "About to leave inner block...\\n";

         // Foo instance will continue to live,
         // despite p2 going out of scope
     }

     std::cout << "About to leave program...\\n";
 }

.SH Output:

 Creating new Foo...
 Foo
 About to leave inner block...
 About to leave program...
 ~Foo
