.TH std::get(std::pair) 3 "Nov 25 2015" "2.1 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::get(std::pair) \- std::get(std::pair)

.SH Synopsis
   template< size_t N, class T1, class T2 >
                                                                (since
   typename std::tuple_element<I, std::pair<T1,T2>          \fB(1)\fP C++11)
   >::type&                                                     (until
                                                                C++14)
       get( pair<T1, T2>& p );
   template< size_t N, class T1, class T2 >

   constexpr std::tuple_element_t<I, std::pair<T1,T2>       \fB(1)\fP (since
   >&                                                           C++14)

       get( pair<T1, T2>& p );
   template< size_t N, class T1, class T2 >
                                                                        (since
   const typename std::tuple_element<I,                         \fB(2)\fP     C++11)
   std::pair<T1,T2> >::type&                                            (until
                                                                        C++14)
       get( const pair<T1,T2>& p );
   template< size_t N, class T1, class T2 >

   constexpr const std::tuple_element_t<I,                      \fB(2)\fP     (since
   std::pair<T1,T2> >&                                                  C++14)

       get( const pair<T1,T2>& p );
   template< size_t N, class T1, class T2 >
                                                                                (since
   typename std::tuple_element<I, std::pair<T1,T2>      \fB(1)\fP             \fB(3)\fP     C++11)
   >::type&&                                                                    (until
                                                                                C++14)
       get( std::pair<T1,T2>&& p );
   template< size_t N, class T1, class T2 >

   constexpr std::tuple_element_t<I, std::pair<T1,T2>       \fB(2)\fP         \fB(3)\fP     (since
   >&&                                                                          C++14)

       get( std::pair<T1,T2>&& p );
   template <class T, class U>

   constexpr T& get(std::pair<T, U>& p);                        \fB(3)\fP             (since
                                                                        \fB(4)\fP     C++14)
   template <class T, class U>

   constexpr const T& get(const std::pair<T, U>& p);
   template <class T, class U>                                          \fB(5)\fP     (since
   constexpr T&& get(std::pair<T, U>&& p);                                      C++14)
   template <class T, class U>

   constexpr T& get(std::pair<U, T>& p);                                        (since
                                                                        \fB(6)\fP     C++14)
   template <class T, class U>

   constexpr const T& get(const std::pair<U, T>& p);
   template <class T, class U>                                          \fB(7)\fP     (since
   constexpr T&& get(std::pair<U, T>&& p);                                      C++14)

   Extracts an element from the pair using tuple-like interface.

   Type-based overloads 4-7 fail to compile if the types T and U are the same.

.SH Parameters

   p - pair whose contents to extract

.SH Return value

   1,2) Returns p.first if N==0 and p.second if N==1.
   3) Returns std::forward<T1&&>(p.first) if N==0 and std::forward<T2&&>(p.second) if
   N==1
   4) Returns std::get<0>(p)
   5) Returns std::get<0>(std::move(p))
   6) Returns std::get<1>(p)
   7) Returns std::get<1>(std::move(p))

.SH Exceptions

   noexcept specification:  
   noexcept
     

.SH Example

   
// Run this code

 #include <iostream>
 #include <utility>
  
 int main()
 {
     auto p = std::make_pair(1, 3.14);
     std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\\n";
     std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\\n";
 }

.SH Output:

 (1, 3.14)
 (1, 3.14)

.SH See also

   std::get(std::tuple) tuple accesses specified element
                        \fI(function template)\fP 
   std::get(std::array) accesses an element of an array
                        \fI(function template)\fP 

.SH Category:

     * unconditionally noexcept
