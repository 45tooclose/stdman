.TH std::shared_ptr::operator*,std::shared_ptr::operator-> 3 "Nov 25 2015" "2.1 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::shared_ptr::operator*,std::shared_ptr::operator-> \- std::shared_ptr::operator*,std::shared_ptr::operator->

.SH Synopsis
   T& operator*() const;  \fB(1)\fP \fI(since C++11)\fP
   T* operator->() const; \fB(2)\fP \fI(since C++11)\fP

   Dereferences pointer to the managed object.

.SH Parameters

   \fI(none)\fP

.SH Return value

   1) reference to the managed object.
   2) pointer to the managed object.

.SH Exceptions

   noexcept specification:  
   noexcept
     

.SH Notes

   When element_type is void, it is unspecified whether function \fB(1)\fP is declared. If it
   is declared, it is unspecified what its return type is, except that the declaration
   (although not necessarily the definition) of the function is guaranteed to be legal.
   This makes it possible to instantiate std::shared_ptr<void>.

.SH Example

   
// Run this code

 #include <iostream>
 #include <memory>
  
 struct Foo
 {
    Foo(int in) : a(in) {}
    void print() const
    {
       std::cout << "a = " << a << '\\n';
    }
    int a;
 };
  
 int main()
 {
    auto ptr = std::make_shared<Foo>(10);
    ptr->print();
    (*ptr).print();
 }

.SH Output:

 a = 10
 a = 10

.SH See also

   get returns a pointer to the managed object
       \fI(public member function)\fP 

.SH Category:

     * unconditionally noexcept
