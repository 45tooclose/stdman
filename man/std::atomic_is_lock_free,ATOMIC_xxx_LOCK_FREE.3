.TH std::atomic_is_lock_free,ATOMIC_xxx_LOCK_FREE 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic_is_lock_free,ATOMIC_xxx_LOCK_FREE \- std::atomic_is_lock_free,ATOMIC_xxx_LOCK_FREE

.SH Synopsis
   Defined in header <atomic>
   template< class T >
   bool atomic_is_lock_free( const volatile
   std::atomic<T>* obj );
   template< class T >
   bool atomic_is_lock_free( const std::atomic<T>*
   obj );
   #define ATOMIC_BOOL_LOCK_FREE     /* unspecified
   */

   #define ATOMIC_CHAR_LOCK_FREE     /* unspecified
   */
   #define ATOMIC_CHAR16_T_LOCK_FREE /* unspecified
   */
   #define ATOMIC_CHAR32_T_LOCK_FREE /* unspecified \fB(1)\fP \fI(since C++11)\fP
   */
   #define ATOMIC_WCHAR_T_LOCK_FREE  /* unspecified
   */                                                                 \fB(2)\fP \fI(since C++11)\fP
   #define ATOMIC_SHORT_LOCK_FREE    /* unspecified
   */
   #define ATOMIC_INT_LOCK_FREE      /* unspecified
   */
   #define ATOMIC_LONG_LOCK_FREE     /* unspecified
   */
   #define ATOMIC_LLONG_LOCK_FREE    /* unspecified
   */

   #define ATOMIC_POINTER_LOCK_FREE  /* unspecified
   */

   1) Determines if the atomic object pointed to by obj is implemented lock-free, as if
   by calling obj->is_lock_free(). In any given program execution, the result of the
   lock-free query is the same for all pointers of the same type.
   2) Expands to an integer constant expression with value

     * 0 for the built-in atomic types that are never lock-free
     * 1 for the built-in atomic types that are sometimes lock-free
     * 2 for the built-in atomic types that are always lock-free.

.SH Parameters

   obj - pointer to the atomic object to examine

.SH Return value

   true if *obj is a lock-free atomic, false otherwise.

.SH Exceptions

   noexcept specification:  
   noexcept
     

.SH Notes

   All atomic types except for std::atomic_flag may be implemented using mutexes or
   other locking operations, rather than using the lock-free atomic CPU instructions.
   Atomic types are also allowed to be sometimes lock-free, e.g. if only aligned memory
   accesses are naturally atomic on a given architecture, misaligned objects of the
   same type have to use locks.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

                                             checks if the atomic object is lock-free
   is_lock_free                              \fI(public member function of std::atomic)\fP
                                             
                                             specializes atomic operations for
   std::atomic_is_lock_free(std::shared_ptr) std::shared_ptr
                                             \fI(function template)\fP
   atomic_flag                               the lock-free boolean atomic type
   \fI(C++11)\fP                                   \fI(class)\fP 
   C documentation for
   atomic_is_lock_free
   C documentation for
   ATOMIC_*_LOCK_FREE

   Categories:

     * unconditionally noexcept
     * Todo no example
