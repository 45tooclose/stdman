.TH std::is_constructible,std::is_trivially_constructible,std::is_nothrow_constructible 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   Defined in header <type_traits>
   template< class T, class... Args > \fB(1)\fP \fI(since C++11)\fP
   struct is_constructible;
   template< class T, class... Args > \fB(2)\fP \fI(since C++11)\fP
   struct is_trivially_constructible;
   template< class T, class... Args > \fB(3)\fP \fI(since C++11)\fP
   struct is_nothrow_constructible;

   1) If the expression T obj(arg1, arg2, ... argN); is well-formed, given rvalue
   references to Args... as arguments, provides the member constant value equal true.
   For any other type, value is false.

   2) same as 1), but the constructor expression does not call any operation that is
   not trivial.

   3) same as 1), but the constructor expression is noexcept.

.SH Contents

     * 1 Inherited from
       std::integral_constant

          * 1.1 Member constants
          * 1.2 Member functions
          * 1.3 Member types
          * 1.4 Example
          * 1.5 See also

Inherited from std::integral_constant

.SH Member constants

   value    true if T is constructible from Args... , false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Example

   
// Run this code

 #include <iostream>
 #include <type_traits>

 class Foo {
     int v1;
     double v2;
  public:
     Foo(int n) : v1(n), v2() {}
     Foo(int n, double f) noexcept : v1(n), v2(f) {}
 };

 int main() {
     std::cout << "Foo is ...\\n" << std::boolalpha
               << "\\tTrivially-constructible from const Foo&? "
               << std::is_trivially_constructible<Foo, const Foo&>::value << '\\n'
               << "\\tTrivially-constructible from int? "
               << std::is_trivially_constructible<Foo, int>::value << '\\n'
               << "\\tConstructible from int? "
               << std::is_constructible<Foo, int>::value << '\\n'
               << "\\tNothrow-constructible from int? "
               << std::is_nothrow_constructible<Foo, int>::value << '\\n'
               << "\\tNothrow-constructible from int and double? "
               << std::is_nothrow_constructible<Foo, int, double>::value << '\\n';
 }

.SH Output:

 Foo is ...
         Trivially-constructible from const Foo&? true
         Trivially-constructible from int? false
         Constructible from int? true
         Nothrow-constructible from int? false
         Nothrow-constructible from int and double? true

.SH See also

   is_default_constructible
   is_trivially_default_constructible
   is_nothrow_default_constructible   checks if a type has a default constructor
   \fI(C++11)\fP                            \fI(class template)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   is_copy_constructible
   is_trivially_copy_constructible
   is_nothrow_copy_constructible      checks if a type has a copy constructor
   \fI(C++11)\fP                            \fI(class template)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   is_move_constructible
   is_trivially_move_constructible
   is_nothrow_move_constructible      checks if a type has a move constructor
   \fI(C++11)\fP                            \fI(class template)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   uses_allocator                     checks if the specified type supports
   \fI(C++11)\fP                            uses-allocator construction
                                      \fI(class template)\fP
