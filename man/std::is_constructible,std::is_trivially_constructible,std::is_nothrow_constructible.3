.TH std::is_constructible,std::is_trivially_constructible,std::is_nothrow_constructible 3 "Nov 25 2015" "2.1 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::is_constructible,std::is_trivially_constructible,std::is_nothrow_constructible \- std::is_constructible,std::is_trivially_constructible,std::is_nothrow_constructible

.SH Synopsis
   Defined in header <type_traits>
   template< class T, class... Args > \fB(1)\fP \fI(since C++11)\fP
   struct is_constructible;
   template< class T, class... Args > \fB(2)\fP \fI(since C++11)\fP
   struct is_trivially_constructible;
   template< class T, class... Args > \fB(3)\fP \fI(since C++11)\fP
   struct is_nothrow_constructible;

   1) If the expression T obj(arg1, arg2, ... argN); is well-formed, given
   declval<Args>()... as arguments, provides the member constant value equal true.
   Otherwise, value is false.

   2) same as 1), but the constructor expression does not call any operation that is
   not trivial.

   3) same as 1), but the constructor expression is noexcept.

   

.SH Member constants

   value    true if T is constructible from Args... , false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP
   operator()    returns value
   \fI(C++14)\fP       \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Example

   
// Run this code

 #include <iostream>
 #include <type_traits>
  
 class Foo {
     int v1;
     double v2;
  public:
     Foo(int n) : v1(n), v2() {}
     Foo(int n, double f) noexcept : v1(n), v2(f) {}
 };
  
 int main() {
     std::cout << "Foo is ...\\n" << std::boolalpha
               << "\\tTrivially-constructible from const Foo&? "
               << std::is_trivially_constructible<Foo, const Foo&>::value << '\\n'
               << "\\tTrivially-constructible from int? "
               << std::is_trivially_constructible<Foo, int>::value << '\\n'
               << "\\tConstructible from int? "
               << std::is_constructible<Foo, int>::value << '\\n'
               << "\\tNothrow-constructible from int? "
               << std::is_nothrow_constructible<Foo, int>::value << '\\n'
               << "\\tNothrow-constructible from int and double? "
               << std::is_nothrow_constructible<Foo, int, double>::value << '\\n';
 }

.SH Output:

 Foo is ...
         Trivially-constructible from const Foo&? true
         Trivially-constructible from int? false
         Constructible from int? true
         Nothrow-constructible from int? false
         Nothrow-constructible from int and double? true

.SH See also

   is_default_constructible
   is_trivially_default_constructible              checks if a type has a default
   is_nothrow_default_constructible                constructor
   \fI(C++11)\fP                                         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   is_copy_constructible
   is_trivially_copy_constructible                 checks if a type has a copy
   is_nothrow_copy_constructible                   constructor
   \fI(C++11)\fP                                         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   is_move_constructible
   is_trivially_move_constructible                 checks if a type has a move
   is_nothrow_move_constructible                   constructor
   \fI(C++11)\fP                                         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   uses_allocator                                  checks if the specified type supports
   \fI(C++11)\fP                                         uses-allocator construction
                                                   \fI(class template)\fP 
   std::experimental::is_constructible_v           variable template alias of
   (library fundamentals TS)                       std::is_constructible::value
                                                   (variable template) 
   std::experimental::is_trivially_constructible_v variable template alias of
   (library fundamentals TS)                       std::is_trivially_constructible::value
                                                   (variable template) 
   std::experimental::is_nothrow_constructible_v   variable template alias of
   (library fundamentals TS)                       std::is_nothrow_constructible::value
                                                   (variable template) 
